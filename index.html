<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <title>The Fidgety Orb</title>
    <style>
        body {
            background: linear-gradient(135deg, #0b0c10 0%, #1f2833 50%, #0b0c10 100%);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
            color: #c5c6c7;
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            text-align: center;
            overflow: hidden;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-container {
            width: 90vmin;
            height: 90vmin;
            max-width: 600px;
            max-height: 600px;
            border: 3px solid #66fcf1;
            box-shadow:
                0 0 20px rgba(102, 252, 241, 0.3),
                0 0 40px rgba(102, 252, 241, 0.1),
                inset 0 0 20px rgba(102, 252, 241, 0.1);
            position: relative;
            background: radial-gradient(circle at center, #1f2833 0%, #0b0c10 100%);
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-style: preserve-3d;
            border-radius: 15px;
        }

        .game-container:hover {
            box-shadow:
                0 0 30px rgba(102, 252, 241, 0.5),
                0 0 60px rgba(102, 252, 241, 0.2),
                inset 0 0 30px rgba(102, 252, 241, 0.2);
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
        }

        #message {
            margin-top: 20px;
            font-size: 1.5em;
            color: #45a29e;
            text-shadow: 1px 1px #0b0c10;
        }

        .level-info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.2em;
            color: #45a29e;
            font-weight: bold;
        }

        .help-text {
            position: absolute;
            bottom: 10px;
            width: 90%;
            font-size: 0.8em;
            color: #45a29e;
        }

        .permission-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .permission-button {
            background-color: #66fcf1;
            color: #0b0c10;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px #66fcf1;
        }

        /* Tilt Animations */
        .tilt-up { transform: rotateX(10deg); }
        .tilt-down { transform: rotateX(-10deg); }
        .tilt-left { transform: rotateY(10deg); }
        .tilt-right { transform: rotateY(-10deg); }
        
        @keyframes glowing-goal {
            0% { box-shadow: 0 0 5px #45a29e, 0 0 10px #45a29e; }
            50% { box-shadow: 0 0 20px #45a29e, 0 0 30px #45a29e; }
            100% { box-shadow: 0 0 5px #45a29e, 0 0 10px #45a29e; }
        }

        @keyframes orb-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes particle-float {
            0% { transform: translateY(0px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(-20px) rotate(360deg); opacity: 0; }
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #66fcf1;
            border-radius: 50%;
            pointer-events: none;
            animation: particle-float 1s ease-out forwards;
        }

        .score-display {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.2em;
            color: #66fcf1;
            font-weight: bold;
            text-shadow: 0 0 10px #66fcf1;
        }

        .power-up-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #ff6b6b, #ff4757);
            border-radius: 50%;
            border: 2px solid #fff;
            display: none;
            animation: orb-pulse 1s infinite;
        }
    </style>
</head>
<body>
    <div class="game-container" id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="level-info">Level: <span id="level">1</span></div>
        <div class="score-display">Score: <span id="score">0</span></div>
        <div class="help-text">Use Arrow Keys or Swipe to Move. Collect power-ups!</div>
        <div class="power-up-indicator" id="powerUpIndicator"></div>

        <div class="permission-overlay" id="permissionOverlay">
            <p>Please tap the button to enable motion controls.</p>
            <button class="permission-button" id="permissionButton">Enable Tilt</button>
        </div>
    </div>
    <div id="message"></div>

    <audio id="moveSound" src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-click-900.mp3"></audio>
    <audio id="winSound" src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3"></audio>
    <audio id="loseSound" src="https://assets.mixkit.co/sfx/preview/mixkit-negative-game-buzz-306.mp3"></audio>
    <audio id="teleportSound" src="https://assets.mixkit.co/sfx/preview/mixkit-fantasy-spell-843.mp3"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const messageEl = document.getElementById('message');
            const levelEl = document.getElementById('level');
            const gameContainer = document.getElementById('gameContainer');
            const permissionOverlay = document.getElementById('permissionOverlay');
            const permissionButton = document.getElementById('permissionButton');

            const moveSound = document.getElementById('moveSound');
            const winSound = document.getElementById('winSound');
            const loseSound = document.getElementById('loseSound');
            const teleportSound = document.getElementById('teleportSound');

            document.addEventListener('gesturestart', (e) => e.preventDefault());
            document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            
            let level = 0;
            let score = 0;
            let orb = {
                x: 0,
                y: 0,
                radius: 18,
                vx: 0,
                vy: 0,
                trail: [],
                glowIntensity: 1,
                speedBoost: 1,
                invincible: false
            };
            let goal = { x: 0, y: 0, radius: 28, pulse: 0 };
            let walls = [];
            let warpGates = [];
            let powerUps = [];
            let particles = [];
            let gameLoop;
            let currentTilt = { x: 0, y: 0 };
            let keys = {};

            const TILT_STRENGTH = 0.8;
            const FRICTION = 0.96;
            const ACCELERATION = 0.3;
            const MAX_SPEED = 8;
            const TRAIL_LENGTH = 15;

            function playSound(audioElement) {
                audioElement.currentTime = 0;
                audioElement.play().catch(e => console.log("Audio play failed:", e));
            }

            function createParticle(x, y, color = '#66fcf1', count = 3) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 60,
                        maxLife: 60,
                        color: color,
                        size: Math.random() * 3 + 2
                    });
                }
            }

            function updateParticles() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1; // gravity
                    p.life--;

                    if (p.life <= 0) {
                        particles.splice(i, 1);
                    }
                }
            }

            function drawParticles() {
                particles.forEach(p => {
                    const alpha = p.life / p.maxLife;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }

            function generateLevel(levelNum) {
                const numWalls = Math.floor(Math.random() * (3 + Math.floor(levelNum / 4))) + 1;
                const numWarpGates = Math.floor(Math.random() * (2 + Math.floor(levelNum / 8)));
                const numPowerUps = Math.floor(Math.random() * (1 + Math.floor(levelNum / 6))) + (levelNum > 3 ? 1 : 0);

                walls = [];
                warpGates = [];
                powerUps = [];
                particles = []; // Clear particles for new level

                // Generate a random orb and goal position, ensuring they are not too close
                let orbPos, goalPos;
                do {
                    orbPos = { x: Math.random() * (canvas.width - 100) + 50, y: Math.random() * (canvas.height - 100) + 50 };
                    goalPos = { x: Math.random() * (canvas.width - 100) + 50, y: Math.random() * (canvas.height - 100) + 50 };
                } while (Math.sqrt(Math.pow(orbPos.x - goalPos.x, 2) + Math.pow(orbPos.y - goalPos.y, 2)) < 250);

                orb.x = orbPos.x;
                orb.y = orbPos.y;
                orb.vx = 0;
                orb.vy = 0;
                orb.trail = [];
                orb.speedBoost = 1;
                orb.invincible = false;
                goal.x = goalPos.x;
                goal.y = goalPos.y;
                goal.pulse = 0;

                // Generate random walls
                for (let i = 0; i < numWalls; i++) {
                    const isCircular = Math.random() > 0.5;
                    if (isCircular) {
                        walls.push({
                            x: Math.random() * (canvas.width - 100) + 50,
                            y: Math.random() * (canvas.height - 100) + 50,
                            isCircle: true,
                            radius: Math.random() * 50 + 20
                        });
                    } else {
                        walls.push({
                            x: Math.random() * (canvas.width - 150) + 50,
                            y: Math.random() * (canvas.height - 150) + 50,
                            width: Math.random() * 100 + 30,
                            height: Math.random() * 100 + 30
                        });
                    }
                }
                
                // Generate random warp gates
                for (let i = 0; i < numWarpGates; i++) {
                    warpGates.push({
                        x: Math.random() * (canvas.width - 100) + 50,
                        y: Math.random() * (canvas.height - 100) + 50,
                        radius: 22,
                        rotation: 0
                    });
                }

                // Generate random power-ups
                for (let i = 0; i < numPowerUps; i++) {
                    const types = ['speed', 'invincibility', 'teleport'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    let color;
                    switch (type) {
                        case 'speed': color = '#ffd700'; break;
                        case 'invincibility': color = '#ff6b6b'; break;
                        case 'teleport': color = '#9c88ff'; break;
                    }

                    powerUps.push({
                        x: Math.random() * (canvas.width - 100) + 50,
                        y: Math.random() * (canvas.height - 100) + 50,
                        radius: 15,
                        type: type,
                        color: color,
                        collected: false
                    });
                }

                showMessage(`Level ${levelNum}: Go!`);
            }
            
            function startGame() {
                level = 1;
                score = 0;
                levelEl.textContent = level;
                document.getElementById('score').textContent = score;
                generateLevel(level);
                gameLoop = setInterval(update, 1000 / 60);
                showMessage("üéÆ Welcome to Fidgety Orb! Use arrow keys or swipe to move.");
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw particle trail for orb
                orb.trail.forEach((pos, index) => {
                    const alpha = (index / orb.trail.length) * 0.3;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#66fcf1';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, orb.radius * (index / orb.trail.length), 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Draw goal with glow effect
                goal.pulse += 0.05;
                const goalGlow = Math.sin(goal.pulse) * 0.3 + 0.7;

                // Outer glow
                ctx.shadowColor = '#45a29e';
                ctx.shadowBlur = 20 * goalGlow;
                ctx.fillStyle = `rgba(69, 162, 158, ${goalGlow * 0.5})`;
                ctx.beginPath();
                ctx.arc(goal.x, goal.y, goal.radius + 10, 0, Math.PI * 2);
                ctx.fill();

                // Goal gradient
                const goalGradient = ctx.createRadialGradient(goal.x, goal.y, 0, goal.x, goal.y, goal.radius);
                goalGradient.addColorStop(0, '#66fcf1');
                goalGradient.addColorStop(1, '#45a29e');
                ctx.shadowBlur = 0;
                ctx.fillStyle = goalGradient;
                ctx.beginPath();
                ctx.arc(goal.x, goal.y, goal.radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw orb with enhanced glow
                orb.glowIntensity = Math.min(orb.glowIntensity + 0.02, 1.5);

                // Orb trail effect
                ctx.shadowColor = '#66fcf1';
                ctx.shadowBlur = 15 * orb.glowIntensity;

                // Orb gradient
                const orbGradient = ctx.createRadialGradient(orb.x - orb.radius * 0.3, orb.y - orb.radius * 0.3, 0, orb.x, orb.y, orb.radius);
                orbGradient.addColorStop(0, '#ffffff');
                orbGradient.addColorStop(0.7, '#66fcf1');
                orbGradient.addColorStop(1, '#45a29e');

                ctx.fillStyle = orbGradient;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();

                // Invincibility effect
                if (orb.invincible) {
                    ctx.shadowColor = '#ff6b6b';
                    ctx.shadowBlur = 20;
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(orb.x, orb.y, orb.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;

                // Draw walls with gradients
                walls.forEach(wall => {
                    if (wall.isCircle) {
                        const wallGradient = ctx.createRadialGradient(wall.x, wall.y, 0, wall.x, wall.y, wall.radius);
                        wallGradient.addColorStop(0, '#c5c6c7');
                        wallGradient.addColorStop(1, '#8c8c8c');
                        ctx.fillStyle = wallGradient;
                        ctx.beginPath();
                        ctx.arc(wall.x, wall.y, wall.radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Wall border
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else {
                        const wallGradient = ctx.createLinearGradient(wall.x, wall.y, wall.x + wall.width, wall.y + wall.height);
                        wallGradient.addColorStop(0, '#c5c6c7');
                        wallGradient.addColorStop(1, '#8c8c8c');
                        ctx.fillStyle = wallGradient;
                        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);

                        // Wall border
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
                    }
                });

                // Draw warp gates with rotation
                warpGates.forEach(gate => {
                    gate.rotation += 0.05;
                    ctx.save();
                    ctx.translate(gate.x, gate.y);
                    ctx.rotate(gate.rotation);

                    const gateGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, gate.radius);
                    gateGradient.addColorStop(0, '#9c88ff');
                    gateGradient.addColorStop(0.7, '#45a29e');
                    gateGradient.addColorStop(1, '#0b0c10');

                    ctx.fillStyle = gateGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, gate.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Inner swirl effect
                    ctx.strokeStyle = '#66fcf1';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const x1 = Math.cos(angle) * (gate.radius * 0.3);
                        const y1 = Math.sin(angle) * (gate.radius * 0.3);
                        const x2 = Math.cos(angle + 0.5) * (gate.radius * 0.8);
                        const y2 = Math.sin(angle + 0.5) * (gate.radius * 0.8);
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                    }
                    ctx.stroke();

                    ctx.restore();
                });

                // Draw power-ups
                powerUps.forEach(powerUp => {
                    if (!powerUp.collected) {
                        const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 0.8;

                        // Power-up glow
                        ctx.shadowColor = powerUp.color;
                        ctx.shadowBlur = 15 * pulse;
                        ctx.fillStyle = powerUp.color;
                        ctx.beginPath();
                        ctx.arc(powerUp.x, powerUp.y, powerUp.radius * pulse, 0, Math.PI * 2);
                        ctx.fill();

                        // Inner circle
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(powerUp.x, powerUp.y, powerUp.radius * 0.6, 0, Math.PI * 2);
                        ctx.fill();

                        // Power-up symbol
                        ctx.fillStyle = powerUp.color;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        let symbol = '?';
                        switch (powerUp.type) {
                            case 'speed': symbol = '‚ö°'; break;
                            case 'invincibility': symbol = 'üõ°Ô∏è'; break;
                            case 'teleport': symbol = '‚ú®'; break;
                        }
                        ctx.fillText(symbol, powerUp.x, powerUp.y);
                    }
                });

                ctx.shadowBlur = 0;

                // Draw particles
                drawParticles();
            }

            function update() {
                // Enhanced physics with acceleration
                if (keys.ArrowLeft || currentTilt.x < -0.1) {
                    orb.vx -= ACCELERATION * orb.speedBoost;
                }
                if (keys.ArrowRight || currentTilt.x > 0.1) {
                    orb.vx += ACCELERATION * orb.speedBoost;
                }
                if (keys.ArrowUp || currentTilt.y < -0.1) {
                    orb.vy -= ACCELERATION * orb.speedBoost;
                }
                if (keys.ArrowDown || currentTilt.y > 0.1) {
                    orb.vy += ACCELERATION * orb.speedBoost;
                }

                // Apply friction and speed limits
                orb.vx *= FRICTION;
                orb.vy *= FRICTION;
                orb.vx = Math.max(-MAX_SPEED * orb.speedBoost, Math.min(MAX_SPEED * orb.speedBoost, orb.vx));
                orb.vy = Math.max(-MAX_SPEED * orb.speedBoost, Math.min(MAX_SPEED * orb.speedBoost, orb.vy));

                orb.x += orb.vx;
                orb.y += orb.vy;

                // Update trail
                orb.trail.unshift({ x: orb.x, y: orb.y });
                if (orb.trail.length > TRAIL_LENGTH) {
                    orb.trail.pop();
                }

                // Update particles
                updateParticles();

                checkCollisions();

                // Check power-up collection
                powerUps.forEach(powerUp => {
                    if (!powerUp.collected) {
                        const dist = Math.sqrt(Math.pow(orb.x - powerUp.x, 2) + Math.pow(orb.y - powerUp.y, 2));
                        if (dist < orb.radius + powerUp.radius) {
                            collectPowerUp(powerUp);
                        }
                    }
                });

                if (Math.sqrt(Math.pow(orb.x - goal.x, 2) + Math.pow(orb.y - goal.y, 2)) < orb.radius + goal.radius) {
                    winGame();
                } else if (orb.x < 0 || orb.x > canvas.width || orb.y < 0 || orb.y > canvas.height) {
                    if (!orb.invincible) {
                        loseGame();
                    } else {
                        // Bounce off edges when invincible
                        if (orb.x < 0) { orb.vx = Math.abs(orb.vx); orb.x = 0; }
                        if (orb.x > canvas.width) { orb.vx = -Math.abs(orb.vx); orb.x = canvas.width; }
                        if (orb.y < 0) { orb.vy = Math.abs(orb.vy); orb.y = 0; }
                        if (orb.y > canvas.height) { orb.vy = -Math.abs(orb.vy); orb.y = canvas.height; }
                    }
                }

                draw();
            }

            function collectPowerUp(powerUp) {
                powerUp.collected = true;
                score += 100;
                document.getElementById('score').textContent = score;
                createParticle(powerUp.x, powerUp.y, powerUp.color, 8);
                playSound(winSound);

                switch (powerUp.type) {
                    case 'speed':
                        orb.speedBoost = 1.5;
                        showMessage("‚ö° Speed Boost Activated!");
                        setTimeout(() => {
                            orb.speedBoost = 1;
                            showMessage("Speed Boost Ended");
                        }, 8000);
                        break;
                    case 'invincibility':
                        orb.invincible = true;
                        showMessage("üõ°Ô∏è Invincibility Activated!");
                        setTimeout(() => {
                            orb.invincible = false;
                            showMessage("Invincibility Ended");
                        }, 10000);
                        break;
                    case 'teleport':
                        const safePos = findSafePosition();
                        orb.x = safePos.x;
                        orb.y = safePos.y;
                        orb.vx = 0;
                        orb.vy = 0;
                        createParticle(orb.x, orb.y, '#9c88ff', 10);
                        showMessage("‚ú® Teleported to Safety!");
                        break;
                }
            }

            function findSafePosition() {
                let attempts = 0;
                while (attempts < 50) {
                    const x = Math.random() * (canvas.width - 100) + 50;
                    const y = Math.random() * (canvas.height - 100) + 50;

                    // Check if position is safe from walls
                    let isSafe = true;
                    walls.forEach(wall => {
                        const dist = Math.sqrt(Math.pow(x - wall.x, 2) + Math.pow(y - wall.y, 2));
                        if ((wall.isCircle && dist < orb.radius + wall.radius) ||
                            (!wall.isCircle && x > wall.x && x < wall.x + wall.width && y > wall.y && y < wall.y + wall.height)) {
                            isSafe = false;
                        }
                    });

                    if (isSafe) {
                        return { x, y };
                    }
                    attempts++;
                }
                return { x: canvas.width / 2, y: canvas.height / 2 };
            }

            function checkCollisions() {
                // Enhanced collision detection with better bouncing
                if (orb.x - orb.radius < 0) {
                    orb.vx = Math.abs(orb.vx) * 0.8;
                    orb.x = orb.radius;
                    createParticle(orb.x, orb.y, '#66fcf1', 3);
                }
                if (orb.x + orb.radius > canvas.width) {
                    orb.vx = -Math.abs(orb.vx) * 0.8;
                    orb.x = canvas.width - orb.radius;
                    createParticle(orb.x, orb.y, '#66fcf1', 3);
                }
                if (orb.y - orb.radius < 0) {
                    orb.vy = Math.abs(orb.vy) * 0.8;
                    orb.y = orb.radius;
                    createParticle(orb.x, orb.y, '#66fcf1', 3);
                }
                if (orb.y + orb.radius > canvas.height) {
                    orb.vy = -Math.abs(orb.vy) * 0.8;
                    orb.y = canvas.height - orb.radius;
                    createParticle(orb.x, orb.y, '#66fcf1', 3);
                }

                walls.forEach(wall => {
                    if (!orb.invincible) {
                        if (wall.isCircle) {
                            const dist = Math.sqrt(Math.pow(orb.x - wall.x, 2) + Math.pow(orb.y - wall.y, 2));
                            if (dist < orb.radius + wall.radius) {
                                const angle = Math.atan2(orb.y - wall.y, orb.x - wall.x);
                                const bounceStrength = 0.8;
                                orb.vx = Math.cos(angle) * Math.abs(orb.vx) * bounceStrength;
                                orb.vy = Math.sin(angle) * Math.abs(orb.vy) * bounceStrength;
                                const overlap = orb.radius + wall.radius - dist;
                                orb.x += Math.cos(angle) * overlap;
                                orb.y += Math.sin(angle) * overlap;
                                createParticle(orb.x, orb.y, '#c5c6c7', 5);
                                orb.glowIntensity = 2;
                                playSound(moveSound);
                            }
                        } else {
                            const closestX = Math.max(wall.x, Math.min(orb.x, wall.x + wall.width));
                            const closestY = Math.max(wall.y, Math.min(orb.y, wall.y + wall.height));
                            const distanceX = orb.x - closestX;
                            const distanceY = orb.y - closestY;
                            const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);
                            if (distanceSquared < (orb.radius * orb.radius)) {
                                const angle = Math.atan2(distanceY, distanceX);
                                const overlap = orb.radius - Math.sqrt(distanceSquared);
                                orb.x += Math.cos(angle) * overlap;
                                orb.y += Math.sin(angle) * overlap;

                                // Better bouncing physics
                                if (Math.abs(distanceX) > Math.abs(distanceY)) {
                                    orb.vx *= -0.8;
                                } else {
                                    orb.vy *= -0.8;
                                }
                                createParticle(orb.x, orb.y, '#c5c6c7', 5);
                                orb.glowIntensity = 2;
                                playSound(moveSound);
                            }
                        }
                    }
                });

                warpGates.forEach(gate => {
                    const dist = Math.sqrt(Math.pow(orb.x - gate.x, 2) + Math.pow(orb.y - gate.y, 2));
                    if (dist < orb.radius + gate.radius) {
                        teleportOrb();
                    }
                });
            }

            function teleportOrb() {
                playSound(teleportSound);
                showMessage("WHOOSH! Teleporting...");
                orb.x = Math.random() * canvas.width;
                orb.y = Math.random() * canvas.height;
                orb.vx = 0;
                orb.vy = 0;
            }

            function winGame() {
                score += level * 50;
                document.getElementById('score').textContent = score;
                showMessage(`üéâ Level ${level} Complete! +${level * 50} points`);
                playSound(winSound);
                createParticle(goal.x, goal.y, '#45a29e', 15);
                clearInterval(gameLoop);
                setTimeout(() => {
                    level++;
                    levelEl.textContent = level;
                    generateLevel(level);
                    gameLoop = setInterval(update, 1000 / 60);
                }, 2500);
            }

            function loseGame() {
                showMessage("üíÄ You fell into the void. Try again.");
                playSound(loseSound);
                createParticle(orb.x, orb.y, '#ff6b6b', 20);
                clearInterval(gameLoop);
                setTimeout(() => {
                    generateLevel(level);
                    gameLoop = setInterval(update, 1000 / 60);
                }, 2500);
            }

            function showMessage(msg) {
                messageEl.textContent = msg;
                setTimeout(() => {
                    messageEl.textContent = '';
                }, 3000);
            }

            // Enhanced keyboard controls with key tracking
            document.addEventListener('keydown', (e) => {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    keys[e.key] = true;

                    // Visual feedback
                    gameContainer.classList.remove('tilt-up', 'tilt-down', 'tilt-left', 'tilt-right');
                    switch (e.key) {
                        case 'ArrowUp': gameContainer.classList.add('tilt-up'); break;
                        case 'ArrowDown': gameContainer.classList.add('tilt-down'); break;
                        case 'ArrowLeft': gameContainer.classList.add('tilt-left'); break;
                        case 'ArrowRight': gameContainer.classList.add('tilt-right'); break;
                    }

                    // Create movement particles occasionally
                    if (Math.random() < 0.3) {
                        createParticle(orb.x, orb.y, '#66fcf1', 2);
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    keys[e.key] = false;
                    gameContainer.classList.remove('tilt-up', 'tilt-down', 'tilt-left', 'tilt-right');
                }
            });
            
            // Touch controls logic
            let touchStartX = null;
            let touchStartY = null;

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (touchStartX === null || touchStartY === null) return;
                
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;

                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0) currentTilt = { x: 1, y: 0 };
                    else currentTilt = { x: -1, y: 0 };
                } else {
                    if (dy > 0) currentTilt = { x: 0, y: 1 };
                    else currentTilt = { x: 0, y: -1 };
                }

                touchStartX = null;
                touchStartY = null;
                playSound(moveSound);

                setTimeout(() => {
                    currentTilt = { x: 0, y: 0 };
                }, 100);
            });

            // Initial game setup
            function resizeCanvas() {
                const container = gameContainer.getBoundingClientRect();
                const size = Math.min(container.width, container.height);
                canvas.width = size - 20; // Account for padding
                canvas.height = size - 20;
            }

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            startGame();
        });
    </script>
</body>
</html>
